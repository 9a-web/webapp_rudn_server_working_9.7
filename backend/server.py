from fastapi import FastAPI, APIRouter, HTTPException
from fastapi.responses import JSONResponse, StreamingResponse
from dotenv import load_dotenv
from starlette.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
import os
import logging
from pathlib import Path
from pydantic import BaseModel, Field
from typing import List, Optional
import uuid
from datetime import datetime, timedelta
import httpx

# –ò–º–ø–æ—Ä—Ç –º–æ–¥—É–ª–µ–π –ø–∞—Ä—Å–µ—Ä–∞ –∏ –º–æ–¥–µ–ª–µ–π
from rudn_parser import (
    get_facultets,
    get_filter_data,
    extract_options,
    get_schedule
)
from models import (
    Faculty,
    FilterDataRequest,
    FilterDataResponse,
    FilterOption,
    ScheduleRequest,
    ScheduleResponse,
    ScheduleEvent,
    UserSettings,
    UserSettingsCreate,
    UserSettingsResponse,
    ErrorResponse,
    SuccessResponse,
    NotificationSettingsUpdate,
    NotificationSettingsResponse,
    Achievement,
    UserAchievement,
    UserAchievementResponse,
    UserStats,
    UserStatsResponse,
    TrackActionRequest,
    NewAchievementsResponse,
    WeatherResponse,
    BotInfo,
    Task,
    TaskCreate,
    TaskUpdate,
    TaskResponse
)
from notifications import get_notification_service
from scheduler import get_scheduler
from cache import cache
from achievements import (
    get_all_achievements,
    get_user_achievements,
    track_user_action,
    get_or_create_user_stats,
    mark_achievements_as_seen
)
from weather import get_moscow_weather


ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# Configure logging early
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# MongoDB connection
mongo_url = os.environ['MONGO_URL']
client = AsyncIOMotorClient(mongo_url)
db = client[os.environ['DB_NAME']]

# Create the main app without a prefix
app = FastAPI(title="RUDN Schedule API", version="1.0.0")

# Configure CORS middleware BEFORE adding routes
# When allow_credentials=True, we cannot use "*" for origins
cors_origins_str = os.environ.get('CORS_ORIGINS', '*')
cors_origins_list = [origin.strip() for origin in cors_origins_str.split(',')]

# Check if "*" is in the list
if '*' in cors_origins_list:
    # If "*" is specified, use it without credentials
    app.add_middleware(
        CORSMiddleware,
        allow_credentials=False,
        allow_origins=["*"],
        allow_methods=["*"],
        allow_headers=["*"],
        expose_headers=["*"],
        max_age=3600,
    )
    logger.info("CORS configured with wildcard (*) - all origins allowed without credentials")
else:
    # If specific origins are provided, enable credentials
    app.add_middleware(
        CORSMiddleware,
        allow_credentials=True,
        allow_origins=cors_origins_list,
        allow_methods=["*"],
        allow_headers=["*"],
        expose_headers=["*"],
        max_age=3600,
    )
    logger.info(f"CORS configured for specific origins: {cors_origins_list}")

# Additional middleware to ensure CORS headers are always present
@app.middleware("http")
async def add_cors_headers(request, call_next):
    response = await call_next(request)
    origin = request.headers.get("origin")
    
    # Always add CORS headers
    if not response.headers.get("access-control-allow-origin"):
        response.headers["access-control-allow-origin"] = "*"
    if not response.headers.get("access-control-allow-methods"):
        response.headers["access-control-allow-methods"] = "DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT"
    if not response.headers.get("access-control-allow-headers"):
        response.headers["access-control-allow-headers"] = "*"
    if not response.headers.get("access-control-max-age"):
        response.headers["access-control-max-age"] = "3600"
        
    return response

# Create a router with the /api prefix
api_router = APIRouter(prefix="/api")


# Define Models (—Å—Ç–∞—Ä—ã–µ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
class StatusCheck(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    client_name: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)

class StatusCheckCreate(BaseModel):
    client_name: str

# ============ –°—Ç–∞—Ä—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã ============
@api_router.get("/")
async def root():
    return {"message": "RUDN Schedule API is running"}

@api_router.post("/status", response_model=StatusCheck)
async def create_status_check(input: StatusCheckCreate):
    status_dict = input.dict()
    status_obj = StatusCheck(**status_dict)
    _ = await db.status_checks.insert_one(status_obj.dict())
    return status_obj

@api_router.get("/status", response_model=List[StatusCheck])
async def get_status_checks():
    status_checks = await db.status_checks.find().to_list(1000)
    return [StatusCheck(**status_check) for status_check in status_checks]


# ============ –≠–Ω–¥–ø–æ–∏–Ω—Ç—ã –¥–ª—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è ============

@api_router.get("/faculties", response_model=List[Faculty])
async def get_faculties():
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–æ–≤ (—Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º –Ω–∞ 60 –º–∏–Ω—É—Ç)"""
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–µ—à
        cached_faculties = cache.get("faculties")
        if cached_faculties:
            return cached_faculties
            
        # –ï—Å–ª–∏ –Ω–µ—Ç –≤ –∫–µ—à–µ, –ø–æ–ª—É—á–∞–µ–º –∏–∑ API
        faculties = await get_facultets()
        if not faculties:
            raise HTTPException(status_code=404, detail="–§–∞–∫—É–ª—å—Ç–µ—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫–µ—à –Ω–∞ 60 –º–∏–Ω—É—Ç
        cache.set("faculties", faculties, ttl_minutes=60)
        return faculties
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–æ–≤: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.post("/filter-data", response_model=FilterDataResponse)
async def get_filter_data_endpoint(request: FilterDataRequest):
    """–ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤ (—É—Ä–æ–≤–Ω–∏, –∫—É—Ä—Å—ã, —Ñ–æ—Ä–º—ã, –≥—Ä—É–ø–ø—ã)"""
    try:
        elements = await get_filter_data(
            facultet_id=request.facultet_id,
            level_id=request.level_id or "",
            kurs=request.kurs or "",
            form_code=request.form_code or ""
        )
        
        response = FilterDataResponse(
            levels=extract_options(elements, "level"),
            courses=extract_options(elements, "kurs"),
            forms=extract_options(elements, "form"),
            groups=extract_options(elements, "group")
        )
        
        return response
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö —Ñ–∏–ª—å—Ç—Ä–∞: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.post("/schedule", response_model=ScheduleResponse)
async def get_schedule_endpoint(request: ScheduleRequest):
    """–ü–æ–ª—É—á–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã"""
    try:
        events = await get_schedule(
            facultet_id=request.facultet_id,
            level_id=request.level_id,
            kurs=request.kurs,
            form_code=request.form_code,
            group_id=request.group_id,
            week_number=request.week_number
        )
        
        # –ö—ç—à–∏—Ä—É–µ–º —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ
        cache_data = {
            "id": str(uuid.uuid4()),
            "group_id": request.group_id,
            "week_number": request.week_number,
            "events": [event for event in events],
            "cached_at": datetime.utcnow(),
            "expires_at": datetime.utcnow() + timedelta(hours=1)
        }
        
        await db.schedule_cache.update_one(
            {"group_id": request.group_id, "week_number": request.week_number},
            {"$set": cache_data},
            upsert=True
        )
        
        return ScheduleResponse(
            events=[ScheduleEvent(**event) for event in events],
            group_id=request.group_id,
            week_number=request.week_number
        )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============ –≠–Ω–¥–ø–æ–∏–Ω—Ç—ã –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ ============

@api_router.get("/user-settings/{telegram_id}", response_model=UserSettingsResponse)
async def get_user_settings(telegram_id: int):
    """–ü–æ–ª—É—á–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ Telegram ID"""
    try:
        user_data = await db.user_settings.find_one({"telegram_id": telegram_id})
        
        if not user_data:
            raise HTTPException(status_code=404, detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        await db.user_settings.update_one(
            {"telegram_id": telegram_id},
            {"$set": {"last_activity": datetime.utcnow()}}
        )
        
        return UserSettingsResponse(**user_data)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.post("/user-settings", response_model=UserSettingsResponse)
async def save_user_settings(settings: UserSettingsCreate):
    """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–ª–∏ –æ–±–Ω–æ–≤–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
        existing_user = await db.user_settings.find_one({"telegram_id": settings.telegram_id})
        
        if existing_user:
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            update_data = settings.dict()
            update_data["updated_at"] = datetime.utcnow()
            update_data["last_activity"] = datetime.utcnow()
            
            await db.user_settings.update_one(
                {"telegram_id": settings.telegram_id},
                {"$set": update_data}
            )
            
            user_data = await db.user_settings.find_one({"telegram_id": settings.telegram_id})
            return UserSettingsResponse(**user_data)
        else:
            # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            user_settings = UserSettings(**settings.dict())
            user_dict = user_settings.dict()
            
            await db.user_settings.insert_one(user_dict)
            
            return UserSettingsResponse(**user_dict)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.delete("/user-settings/{telegram_id}", response_model=SuccessResponse)
async def delete_user_settings(telegram_id: int):
    """–£–¥–∞–ª–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        result = await db.user_settings.delete_one({"telegram_id": telegram_id})
        
        if result.deleted_count == 0:
            raise HTTPException(status_code=404, detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
        
        return SuccessResponse(success=True, message="–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —É–¥–∞–ª–µ–Ω—ã")
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.get("/schedule-cached/{group_id}/{week_number}", response_model=Optional[ScheduleResponse])
async def get_cached_schedule(group_id: str, week_number: int):
    """–ü–æ–ª—É—á–∏—Ç—å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ"""
    try:
        cached = await db.schedule_cache.find_one({
            "group_id": group_id,
            "week_number": week_number,
            "expires_at": {"$gt": datetime.utcnow()}
        })
        
        if not cached:
            return None
        
        return ScheduleResponse(
            events=[ScheduleEvent(**event) for event in cached["events"]],
            group_id=cached["group_id"],
            week_number=cached["week_number"]
        )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫—ç—à–∞: {e}")
        return None


# ============ –≠–Ω–¥–ø–æ–∏–Ω—Ç—ã –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è–º–∏ ============

@api_router.put("/user-settings/{telegram_id}/notifications", response_model=NotificationSettingsResponse)
async def update_notification_settings(telegram_id: int, settings: NotificationSettingsUpdate):
    """–û–±–Ω–æ–≤–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user = await db.user_settings.find_one({"telegram_id": telegram_id})
        
        if not user:
            raise HTTPException(status_code=404, detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
        await db.user_settings.update_one(
            {"telegram_id": telegram_id},
            {"$set": {
                "notifications_enabled": settings.notifications_enabled,
                "notification_time": settings.notification_time,
                "updated_at": datetime.utcnow()
            }}
        )
        
        # –ï—Å–ª–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤–∫–ª—é—á–µ–Ω—ã, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
        test_notification_sent = None
        test_notification_error = None
        
        if settings.notifications_enabled:
            try:
                notification_service = get_notification_service()
                success = await notification_service.send_test_notification(telegram_id)
                test_notification_sent = success
                if not success:
                    test_notification_error = "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤—ã –Ω–∞—á–∞–ª–∏ –¥–∏–∞–ª–æ–≥ —Å –±–æ—Ç–æ–º –∫–æ–º–∞–Ω–¥–æ–π /start"
            except Exception as e:
                logger.warning(f"Failed to send test notification: {e}")
                test_notification_sent = False
                test_notification_error = f"–û—à–∏–±–∫–∞: {str(e)}. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –¥–∏–∞–ª–æ–≥ —Å –±–æ—Ç–æ–º –∫–æ–º–∞–Ω–¥–æ–π /start –≤ Telegram"
        
        return NotificationSettingsResponse(
            notifications_enabled=settings.notifications_enabled,
            notification_time=settings.notification_time,
            telegram_id=telegram_id,
            test_notification_sent=test_notification_sent,
            test_notification_error=test_notification_error
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.get("/user-settings/{telegram_id}/notifications", response_model=NotificationSettingsResponse)
async def get_notification_settings(telegram_id: int):
    """–ü–æ–ª—É—á–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        user = await db.user_settings.find_one({"telegram_id": telegram_id})
        
        if not user:
            raise HTTPException(status_code=404, detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
        
        return NotificationSettingsResponse(
            notifications_enabled=user.get("notifications_enabled", False),
            notification_time=user.get("notification_time", 10),
            telegram_id=telegram_id
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============ –≠–Ω–¥–ø–æ–∏–Ω—Ç—ã –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π ============

@api_router.get("/achievements", response_model=List[Achievement])
async def get_achievements():
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π"""
    try:
        achievements = get_all_achievements()
        return achievements
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.get("/user-achievements/{telegram_id}", response_model=List[UserAchievementResponse])
async def get_user_achievements_endpoint(telegram_id: int):
    """–ü–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        achievements = await get_user_achievements(db, telegram_id)
        return achievements
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.get("/user-stats/{telegram_id}", response_model=UserStatsResponse)
async def get_user_stats_endpoint(telegram_id: int):
    """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        stats = await get_or_create_user_stats(db, telegram_id)
        return UserStatsResponse(
            telegram_id=stats.telegram_id,
            groups_viewed=stats.groups_viewed,
            friends_invited=stats.friends_invited,
            schedule_views=stats.schedule_views,
            night_usage_count=stats.night_usage_count,
            early_usage_count=stats.early_usage_count,
            total_points=stats.total_points,
            achievements_count=stats.achievements_count
        )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.post("/track-action", response_model=NewAchievementsResponse)
async def track_action_endpoint(request: TrackActionRequest):
    """–û—Ç—Å–ª–µ–¥–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è"""
    try:
        # –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –¥–µ–π—Å—Ç–≤–∏–µ –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
        new_achievements = await track_user_action(
            db,
            request.telegram_id,
            request.action_type,
            request.metadata
        )
        
        return new_achievements
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–∏ –¥–µ–π—Å—Ç–≤–∏—è: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.post("/user-achievements/{telegram_id}/mark-seen", response_model=SuccessResponse)
async def mark_achievements_seen_endpoint(telegram_id: int):
    """–û—Ç–º–µ—Ç–∏—Ç—å –≤—Å–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –∫–∞–∫ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω—ã–µ"""
    try:
        await mark_achievements_as_seen(db, telegram_id)
        return SuccessResponse(success=True, message="–î–æ—Å—Ç–∏–∂–µ–Ω–∏—è –æ—Ç–º–µ—á–µ–Ω—ã –∫–∞–∫ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω—ã–µ")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ—Ç–∫–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============ –≠–Ω–¥–ø–æ–∏–Ω—Ç—ã –¥–ª—è –ø–æ–≥–æ–¥—ã ============

@api_router.get("/weather", response_model=WeatherResponse)
async def get_weather_endpoint():
    """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â—É—é –ø–æ–≥–æ–¥—É –≤ –ú–æ—Å–∫–≤–µ (—Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º –Ω–∞ 10 –º–∏–Ω—É—Ç)"""
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–µ—à
    cached_weather = cache.get("weather")
    if cached_weather:
        return cached_weather
    
    try:
        weather = await get_moscow_weather()
        
        if not weather:
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º mock –¥–∞–Ω–Ω—ã–µ –≤–º–µ—Å—Ç–æ –æ—à–∏–±–∫–∏
            logger.warning("Weather API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º mock –¥–∞–Ω–Ω—ã–µ")
            weather = WeatherResponse(
                temperature=5,
                feels_like=2,
                humidity=85,
                wind_speed=15,
                description="–û–±–ª–∞—á–Ω–æ",
                icon="‚òÅÔ∏è"
            )
        
        # –ö–µ—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–∞ 10 –º–∏–Ω—É—Ç
        cache.set("weather", weather, ttl_minutes=10)
        return weather
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–≥–æ–¥—ã: {e}")
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º mock –¥–∞–Ω–Ω—ã–µ –≤–º–µ—Å—Ç–æ –æ—à–∏–±–∫–∏
        return WeatherResponse(
            temperature=5,
            feels_like=2,
            humidity=85,
            wind_speed=15,
            description="–û–±–ª–∞—á–Ω–æ",
            icon="‚òÅÔ∏è"
        )


# ============ –≠–Ω–¥–ø–æ–∏–Ω—Ç—ã –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±–æ—Ç–µ ============

@api_router.get("/bot-info", response_model=BotInfo)
async def get_bot_info():
    """–ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–æ—Ç–µ (username, id –∏ —Ç.–¥.) —Å –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º –Ω–∞ 1 —á–∞—Å"""
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–µ—à
    cached_bot_info = cache.get("bot_info")
    if cached_bot_info:
        return cached_bot_info
    
    try:
        from telegram import Bot
        
        bot_token = os.environ.get('TELEGRAM_BOT_TOKEN')
        if not bot_token:
            raise HTTPException(status_code=500, detail="Bot token –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
        
        bot = Bot(token=bot_token)
        me = await bot.get_me()
        
        bot_info = BotInfo(
            username=me.username or "",
            first_name=me.first_name,
            id=me.id,
            can_join_groups=me.can_join_groups or False,
            can_read_all_group_messages=me.can_read_all_group_messages or False,
            supports_inline_queries=me.supports_inline_queries or False
        )
        
        # –ö–µ—à–∏—Ä—É–µ–º –Ω–∞ 1 —á–∞—Å
        cache.set("bot_info", bot_info, ttl_minutes=60)
        return bot_info
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –±–æ—Ç–µ: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.get("/user-profile-photo/{telegram_id}")
async def get_user_profile_photo(telegram_id: int):
    """–ü–æ–ª—É—á–∏—Ç—å URL —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ Telegram"""
    try:
        from telegram import Bot
        
        bot_token = os.environ.get('TELEGRAM_BOT_TOKEN')
        if not bot_token:
            return JSONResponse({"photo_url": None})
        
        bot = Bot(token=bot_token)
        
        # –ü–æ–ª—É—á–∞–µ–º —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        photos = await bot.get_user_profile_photos(telegram_id, limit=1)
        
        if photos.total_count > 0:
            # –ë–µ—Ä—ë–º —Å–∞–º–æ–µ –±–æ–ª—å—à–æ–µ —Ñ–æ—Ç–æ (–ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤ —Å–ø–∏—Å–∫–µ sizes)
            photo = photos.photos[0][-1]
            file = await bot.get_file(photo.file_id)
            
            # file.file_path –º–æ–∂–µ—Ç –±—ã—Ç—å –∫–∞–∫ –ø–æ–ª–Ω—ã–º URL, —Ç–∞–∫ –∏ –ø—Ä–æ—Å—Ç–æ –ø—É—Ç—ë–º
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å–ª–∏ —ç—Ç–æ —É–∂–µ URL, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ, –∏–Ω–∞—á–µ —Ñ–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π URL
            if file.file_path.startswith('http'):
                full_url = file.file_path
            else:
                full_url = f"https://api.telegram.org/file/bot{bot_token}/{file.file_path}"
            
            logger.info(f"Profile photo URL for {telegram_id}: {full_url}")
            return JSONResponse({"photo_url": full_url})
        else:
            return JSONResponse({"photo_url": None})
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è: {e}")
        return JSONResponse({"photo_url": None})


@api_router.get("/user-profile-photo-proxy/{telegram_id}")
async def get_user_profile_photo_proxy(telegram_id: int):
    """–ü–æ–ª—É—á–∏—Ç—å —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ –ø—Ä–æ–∫—Å–∏ (–¥–ª—è –æ–±—Ö–æ–¥–∞ CORS)"""
    try:
        from telegram import Bot
        
        bot_token = os.environ.get('TELEGRAM_BOT_TOKEN')
        if not bot_token:
            raise HTTPException(status_code=404, detail="Bot token not configured")
        
        bot = Bot(token=bot_token)
        
        # –ü–æ–ª—É—á–∞–µ–º —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        photos = await bot.get_user_profile_photos(telegram_id, limit=1)
        
        if photos.total_count > 0:
            # –ë–µ—Ä—ë–º —Å–∞–º–æ–µ –±–æ–ª—å—à–æ–µ —Ñ–æ—Ç–æ (–ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤ —Å–ø–∏—Å–∫–µ sizes)
            photo = photos.photos[0][-1]
            file = await bot.get_file(photo.file_id)
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º URL –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏
            if file.file_path.startswith('http'):
                image_url = file.file_path
            else:
                image_url = f"https://api.telegram.org/file/bot{bot_token}/{file.file_path}"
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            async with httpx.AsyncClient() as client:
                response = await client.get(image_url)
                if response.status_code == 200:
                    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º content-type
                    return StreamingResponse(
                        iter([response.content]),
                        media_type=response.headers.get('content-type', 'image/jpeg'),
                        headers={
                            'Cache-Control': 'public, max-age=86400',  # –ö–µ—à–∏—Ä—É–µ–º –Ω–∞ 24 —á–∞—Å–∞
                        }
                    )
        
        raise HTTPException(status_code=404, detail="Profile photo not found")
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ–∏–ª—è: {e}")
        raise HTTPException(status_code=500, detail="Failed to load profile photo")


# ============ –≠–Ω–¥–ø–æ–∏–Ω—Ç—ã –¥–ª—è —Å–ø–∏—Å–∫–∞ –¥–µ–ª ============

@api_router.get("/tasks/{telegram_id}", response_model=List[TaskResponse])
async def get_user_tasks(telegram_id: int):
    """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∑–∞–¥–∞—á–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ order (–ø–æ—Ä—è–¥–æ–∫ drag & drop), –∑–∞—Ç–µ–º –ø–æ created_at
        tasks = await db.tasks.find({"telegram_id": telegram_id}).sort([("order", 1), ("created_at", -1)]).to_list(1000)
        return [TaskResponse(**task) for task in tasks]
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∑–∞–¥–∞—á: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.post("/tasks", response_model=TaskResponse)
async def create_task(task_data: TaskCreate):
    """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∑–∞–¥–∞—á—É"""
    try:
        logger.info(f"üìù Creating task with target_date: {task_data.target_date}, deadline: {task_data.deadline}")
        
        # –ü–æ–ª—É—á–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π order –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        max_order_task = await db.tasks.find_one(
            {"telegram_id": task_data.telegram_id},
            sort=[("order", -1)]
        )
        
        # –ü—Ä–∏—Å–≤–∞–∏–≤–∞–µ–º order = max + 1 (–∏–ª–∏ 0, –µ—Å–ª–∏ –∑–∞–¥–∞—á –Ω–µ—Ç)
        next_order = (max_order_task.get("order", -1) + 1) if max_order_task else 0
        
        task = Task(**task_data.dict(), order=next_order)
        task_dict = task.dict()
        
        logger.info(f"üíæ Saving task to DB: target_date={task_dict.get('target_date')}, deadline={task_dict.get('deadline')}")
        
        await db.tasks.insert_one(task_dict)
        
        logger.info(f"‚úÖ Task created successfully: id={task_dict['id']}")
        
        return TaskResponse(**task_dict)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–¥–∞—á–∏: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.put("/tasks/{task_id}", response_model=TaskResponse)
async def update_task(task_id: str, task_update: TaskUpdate):
    """–û–±–Ω–æ–≤–∏—Ç—å –∑–∞–¥–∞—á—É (–≤—Å–µ –ø–æ–ª—è –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã)"""
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏
        existing_task = await db.tasks.find_one({"id": task_id})
        
        if not existing_task:
            raise HTTPException(status_code=404, detail="–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–µ–¥–∞–Ω–Ω—ã–µ –ø–æ–ª—è
        update_data = {}
        if task_update.text is not None:
            update_data["text"] = task_update.text
        if task_update.completed is not None:
            update_data["completed"] = task_update.completed
        if task_update.category is not None:
            update_data["category"] = task_update.category
        if task_update.priority is not None:
            update_data["priority"] = task_update.priority
        if task_update.deadline is not None:
            update_data["deadline"] = task_update.deadline
        if task_update.target_date is not None:
            update_data["target_date"] = task_update.target_date
        if task_update.subject is not None:
            update_data["subject"] = task_update.subject
        if task_update.discipline_id is not None:
            update_data["discipline_id"] = task_update.discipline_id
        if task_update.order is not None:
            update_data["order"] = task_update.order
        
        update_data["updated_at"] = datetime.utcnow()
        
        await db.tasks.update_one(
            {"id": task_id},
            {"$set": update_data}
        )
        
        # –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—É—é –∑–∞–¥–∞—á—É
        updated_task = await db.tasks.find_one({"id": task_id})
        
        return TaskResponse(**updated_task)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.delete("/tasks/{task_id}", response_model=SuccessResponse)
async def delete_task(task_id: str):
    """–£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É"""
    try:
        result = await db.tasks.delete_one({"id": task_id})
        
        if result.deleted_count == 0:
            raise HTTPException(status_code=404, detail="–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
        
        return SuccessResponse(success=True, message="–ó–∞–¥–∞—á–∞ —É–¥–∞–ª–µ–Ω–∞")
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.put("/tasks/reorder", response_model=SuccessResponse)
async def reorder_tasks(task_orders: List[dict]):
    """
    –û–±–Ω–æ–≤–∏—Ç—å –ø–æ—Ä—è–¥–æ–∫ –∑–∞–¥–∞—á (batch update)
    –ü—Ä–∏–Ω–∏–º–∞–µ—Ç –º–∞—Å—Å–∏–≤ –æ–±—ä–µ–∫—Ç–æ–≤: [{"id": "task_id", "order": 0}, ...]
    """
    try:
        # –û–±–Ω–æ–≤–ª—è–µ–º order –¥–ª—è –∫–∞–∂–¥–æ–π –∑–∞–¥–∞—á–∏
        for task_order in task_orders:
            task_id = task_order.get("id")
            order = task_order.get("order")
            
            if task_id is not None and order is not None:
                await db.tasks.update_one(
                    {"id": task_id},
                    {"$set": {"order": order, "updated_at": datetime.utcnow()}}
                )
        
        return SuccessResponse(success=True, message=f"–û–±–Ω–æ–≤–ª–µ–Ω –ø–æ—Ä—è–¥–æ–∫ {len(task_orders)} –∑–∞–¥–∞—á")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –ø–æ—Ä—è–¥–∫–∞ –∑–∞–¥–∞—á: {e}")
        raise HTTPException(status_code=500, detail=str(e))



# Include the router in the main app
app.include_router(api_router)


# ============ –°–æ–±—ã—Ç–∏—è –∂–∏–∑–Ω–µ–Ω–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ============

@app.on_event("startup")
async def startup_event():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    logger.info("Starting RUDN Schedule API...")
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
    try:
        scheduler = get_scheduler(db)
        scheduler.start()
        logger.info("Notification scheduler started successfully")
    except Exception as e:
        logger.error(f"Failed to start notification scheduler: {e}")


@app.on_event("shutdown")
async def shutdown_db_client():
    """–û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ"""
    logger.info("Shutting down RUDN Schedule API...")
    
    # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫
    try:
        scheduler = get_scheduler(db)
        scheduler.stop()
        logger.info("Notification scheduler stopped")
    except Exception as e:
        logger.error(f"Error stopping scheduler: {e}")
    
    # –ó–∞–∫—Ä—ã–≤–∞–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î
    client.close()
    logger.info("Database connection closed")
